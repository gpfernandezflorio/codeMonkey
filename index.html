<html style="overflow-y:hidden;font-family: monospace;">
  <div style="border: solid 1px; border-radius: 3px; padding: 6px; margin-bottom: 3px;">
    Lenguaje: <select id="selectorLenguaje" name="lenguaje">
    </select>
    Mecanismo de recorrido: <select id="selectorMecanismo" name="mecanismo">
    </select>
  </div>
  <div style="border: solid 1px; border-radius: 3px; padding: 6px; margin-bottom: 3px;">
  <select id="selectorClase" name="clase">
    </select>
    <input type="text" value="PintarTableroRojo" id="selectorNombre">
    <span id="abrirDefinición">() {</span>
    <br/>
    <span id="abrirComentario" style="margin-left:10px;">/*</span>
    <br/>
    <span style="margin-left:20px;">
      Observación: Es un recorrido de
      <select id="selectorTipo" name="tipo">
      </select>
      sobre
      <select id="selectorColeccion" name="coleccion">
      </select>
      </span>
      <br/>
      <span style="margin-left:30px;">
      usando como subtarea
    </span>
    <input type="text" value="PonerUnaRoja" id="selectorSubtarea">
    <br/>
    <span id="cerrarComentario" style="margin-left:10px;">*/</span>
    <br/>
    <span id="cerrarDefinición">}</span>
  </div>
  <b>Código generado</b>:<br/>
  <textarea id="output" style="width:100%;height:50%;background-color: #e0e0e0;" readonly></textarea>
  <script>
    const codigosImport = {
      P:{
        Enum:"from enum import Enum",
        Color:"class Color(Enum):\n  Azul = 1\n  Negro = 2\n  Rojo = 3\n  Verde = 4",
        Dir:"class Dirección(Enum):\n  Norte = 1\n  Este = 2\n  Sur = 3\n  Oeste = 4"
      },
      J:{
        Color:"const Color = {\n  Azul: Symbol('Azul'),\n  Negro: Symbol('Negro'),\n  Rojo: Symbol('Rojo'),\n  Verde: Symbol('Verde')\n};\nObject.freeze(Color);",
        Dir:"const Dirección = {\n  Norte: Symbol('Norte'),\n  Este: Symbol('Este'),\n  Sur: Symbol('Sur'),\n  Oeste: Symbol('Oeste')\n};\nObject.freeze(Dirección);"
      },
      H:{
        List:"import Data.List",
        Maybe:"import Data.Maybe",
        Color:"Data Color = Azul | Negro | Rojo | Verde",
        Dir:"Data Dirección = Norte | Este | Sur | Oeste"
      }
    };
    const codigosBiblioteca = {
      G:{
        unoSi_OCeroSiNo:"function unoSi_OCeroSiNo(condición) {\n  return (choose 1 when (condición)\n                 0 otherwise)\n}",
        singular_Si_:"function singular_Si_(elemnto, condición) {\n  return (choose [elemento] when (condición)\n                 [] otherwise)\n}"
      },
      P:{
        unoSi_OCeroSiNo:"def unoSi_OCeroSiNo(condición):\n  return 1 if condición else 0",
        singular_Si_:"def singular_Si_(elemento, condición):\n return [elemento] if condición else []",
        minColor:"def minColor():\n  return Color.Azul",
        maxColor:"def maxColor():\n  return Color.Verde",
        colorSiguiente:"def colorSiguiente(color):\n  match color:\n    case Color.Azul:\n      return Color.Negro\n    case Color.Negro:\n      return Color.Rojo\n    case Color.Rojo:\n      return Color.Verde",
        minDir:"def minDir():\n  return Dirección.Norte",
        maxDir:"def maxDir():\n  return Dirección.Oeste",
        dirSiguiente:"def dirSiguiente(dirección):\n  match dirección:\n    case Dirección.Norte:\n      return Dirección.Este\n    case Dirección.Este:\n      return Dirección.Sur\n    case Dirección.Sur:\n      return Dirección.Oeste"
      },
      J:{
        unoSi_OCeroSiNo:"function unoSi_OCeroSiNo(condición) {\n  return condición ? 1 : 0;\n}",
        singular_Si_:"function singular_Si_(elemento, condición) {\n  return condición ? [elemento] : [];\n}",
        minColor:"function minColor() {\n  return Color.Azul;\n}",
        maxColor:"function maxColor() {\n  return Color.Verde;\n}",
        colorSiguiente:"function colorSiguiente(color) {\n  switch(color) {\n    case Color.Azul:\n      return Color.Negro;\n    case Color.Negro:\n      return Color.Rojo;\n    case Color.Rojo:\n      return Dirección.Verde;\n  }\n}",
        minDir:"function minDir() {\n  return Dirección.Norte;\n}",
        maxDir:"function maxDir() {\n  return Dirección.Oeste;\n}",
        dirSiguiente:"function dirSiguiente(dirección) {\n  switch(dirección) {\n    case Dirección.Norte:\n      return Dirección.Este;\n    case Dirección.Este:\n      return Dirección.Sur;\n    case Dirección.Sur:\n      return Dirección.Oeste;\n  }\n}"
      },
      H:{
        unoSi_OCeroSiNo:"unoSi_OCeroSiNo condición = if condición then 1 else 0",
        minColor:"minColor = Azul",
        maxColor:"maxColor = Verde",
        colorSiguiente:"colorSiguiente Azul = Negro\ncolorSiguiente Negro = Rojo\ncolorSiguiente Rojo = Verde",
        minDir:"minDir = Norte",
        maxDir:"maxDir = Oeste",
        dirSiguiente:"dirSiguiente Norte = Este\ndirSiguiente Este = Sur\ndirSiguiente Sur = Oeste\n"
      }
    };
    const codigosTipo = {
      G:{
        P:{
          w:{
            E:"%{I}while(%{E}){\n  %{P}\n%{N}%{B}",
            P:"%{S}(%{A})"
          },
          f:{
            E:"%{I}foreach %{F} {\n  %{P}\n%{N}%{B}",
            P:"%{S}(%{A})"
          }
        },
        A:{
          w:{
            E:"%{I}contador := 0\nwhile(%{E}){\n  %{P}\n%{N}%{B}%{R}",
            P:"contador := contador + %{S}(%{A})", R:"return(contador)"
          },
          f:{
            E:"%{I}contador := 0\nforeach %{F} {\n  %{P}\n%{N}%{B}%{R}",
            P:"contador := contador + %{S}(%{A})", R:"return(contador)"
          }
        },
        AC:{
          w:{
            E:"%{I}contador := 0\nwhile(%{E}){\n  %{P}\n%{N}%{B}%{R}",
            P:"contador := contador + unoSi_OCeroSiNo(%{S}(%{A}))",
            R:"return(contador)", bib:["unoSi_OCeroSiNo"]
          },
          f:{
            E:"%{I}contador := 0\nforeach %{F} {\n  %{P}\n%{N}%{B}%{R}",
            P:"contador := contador + unoSi_OCeroSiNo(%{S}(%{A}))",
            R:"return(contador)", bib:["unoSi_OCeroSiNo"]
          }
        },
        B:{
          w:{
            E:"%{I}while(%{E} && not %{S}(%{A})){\n%{N}%{R}",
            R:"return(%{R})"
          }
        },
        BS:{
          w:{
            E:"%{I}while(not %{S}(%{A})){\n%{N}%{R}",
            R:"return(%{A})"
          }
        },
        M:{
          w:{
            E:"%{I}mejorPorAhora := %{A}\nwhile(%{E}){\n  %{P}\n%{N}%{B}%{R}",
            P:"mejorPorAhora := %{S}(mejorPorAhora, %{A})", R:"return(mejorPorAhora)"
          },
          f:{
            E:"%{I}mejorPorAhora := %{H}\nforeach %{T} {\n  %{P}\n%{N}%{B}%{R}",
            P:"mejorPorAhora := %{S}(mejorPorAhora, %{A})", R:"return(mejorPorAhora)"
          }
        },
        T:{
          w:{
            E:"%{I}listaTransformadaPorAhora := []\nwhile(%{E}){\n  %{P}\n%{N}%{B}%{R}",
            P:"listaTransformadaPorAhora := listaTransformadaPorAhora ++ [%{S}(%{A})]",
            R:"return(listaTransformadaPorAhora)"
          },
          f:{
            E:"%{I}listaTransformadaPorAhora := []\nforeach %{F} {\n  %{P}\n%{N}%{B}%{R}",
            P:"listaTransformadaPorAhora := listaTransformadaPorAhora ++ [%{S}(%{A})]",
            R:"return(listaTransformadaPorAhora)"
          }
        },
        F:{
          w:{
            E:"%{I}listaFiltradaPorAhora := []\nwhile(%{E}){\n  %{P}\n%{N}%{B}%{R}",
            P:"listaFiltradaPorAhora := listaFiltradaPorAhora ++\n  singular_Si_(%{A}, %{S}(%{A}))",
            R:"return(listaFiltradaPorAhora)", bib:["singular_Si_"]
          },
          f:{
            E:"%{I}listaFiltradaPorAhora := []\nforeach %{F} {\n  %{P}\n%{N}%{B}%{R}",
            P:"listaFiltradaPorAhora := listaFiltradaPorAhora ++\n  singular_Si_(%{A}, %{S}(%{A}))",
            R:"return(listaFiltradaPorAhora)", bib:["singular_Si_"]
          }
        }
      },
      P:{
        A:{
          w:{
            E:"%{I}contador = 0\nwhile %{E}:\n  %{P}\n%{N}%{B}%{R}",
            P:"contador = contador + %{S}(%{A})", R:"return contador"
          },
          f:{
            E:"%{I}contador = 0\nfor %{F}:\n  %{P}%{N}%{B}%{R}",
            P:"contador = contador + %{S}(%{A})", R:"return contador"
          },
          r:{
            E:"return %{REC}(%{T}) + %{S}(%{H}) if %{E} else 0"
          },
          h:{
            E:"TODO"
          }
        },
        AC:{
          w:{
            E:"%{I}contador = 0\nwhile %{E}:\n  %{P}\n%{N}%{B}%{R}",
            P:"contador = contador + (1 if %{S}(%{A}) else 0)", R:"return contador"
          },
          f:{
            E:"%{I}contador = 0\nfor %{F}:\n  %{P}%{N}%{B}%{R}",
            P:"contador = contador + unoSi_OCeroSiNo(%{S}(%{A}))", R:"return contador",
            bib:["unoSi_OCeroSiNo"]
          },
          r:{
            E:"return %{REC}(%{T}) + unoSi_OCeroSiNo(%{S}(%{H})) if %{E} else 0",
            bib:["unoSi_OCeroSiNo"]
          },
          h:{
            E:"TODO"
          }
        },
        B:{
          w:{
            E:"%{I}while %{E} and not %{S}(%{A}):\n%{N}%{R}",
            R:"return %{R}"
          },
          r:{
            E:"return %{E} and (%{S}(%{H}) or %{REC}(%{T}))"
          },
          h:{
            E:"TODO"
          }
        },
        BS:{
          w:{
            E:"%{I}while not %{S}(%{A}):\n%{N}%{R}",
            R:"return %{A}"
          },
          r:{
            EP:"if not %{S}(%{H}):\n%{N}%{REC}(%{T})",
            EF:"return %{H} if %{S}(%{H}) else %{REC}(%{T})"
          },
          h:{
            E:"TODO"
          }
        },
        M:{
          w:{
            E:"%{I}mejorPorAhora = %{A}\nwhile %{E}:\n  %{P}\n%{N}%{B}%{R}",
            P:"mejorPorAhora = %{S}(mejorPorAhora, %{A})", R:"return mejorPorAhora"
          },
          f:{
            E:"%{I}mejorPorAhora = %{H}\nfor %{T}:\n  %{P}%{N}%{B}%{R}",
            P:"mejorPorAhora = %{S}(mejorPorAhora, %{A})", R:"return mejorPorAhora"
          },
          r:{
            E:"return %{S}(%{REC}(%{T}), %{H}) if %{Em} else %{H}"
          },
          h:{
            E:"TODO"
          }
        },
        T:{
          w:{
            E:"%{I}listaTransformadaPorAhora = []\nwhile %{E}:\n  %{P}\n%{N}%{B}%{R}",
            P:"listaTransformadaPorAhora.append(%{S}(%{A}))",
            R:"return listaTransformadaPorAhora"
          },
          f:{
            E:"%{I}listaTransformadaPorAhora = []\nfor %{F}:\n  %{P}%{N}%{B}%{R}",
            P:"listaTransformadaPorAhora.append(%{S}(%{A}))",
            R:"return listaTransformadaPorAhora"
          },
          r:{
            E:"return %{S}(%{H}) + %{REC}(%{T}) if %{E} else []"
          },
          h:{
            E:"TODO"
          }
        },
        F:{
          w:{
            E:"%{I}listaFiltradaPorAhora = []\nwhile %{E}:\n  %{P}\n%{N}%{B}%{R}",
            P:"if %{S}(%{A}):\n  listaFiltradaPorAhora.append(%{A})",
            R:"return listaFiltradaPorAhora"
          },
          f:{
            E:"%{I}listaFiltradaPorAhora = []\nfor %{F}:\n  %{P}%{N}%{B}%{R}",
            P:"if %{S}(%{A}):\n  listaFiltradaPorAhora.append(%{A})",
            R:"return listaFiltradaPorAhora"
          },
          r:{
            E:"return singular_Si_(%{H}, %{S}(%{H})) + %{REC}(%{T}) if %{E} else []",
            bib:["singular_Si_"]
          },
          h:{
            E:"TODO"
          }
        }
      },
      J:{
        A:{
          w:{
            E:"%{I}contador = 0;\nwhile(%{E}){\n  %{P}\n%{N}%{B}%{R}",
            P:"contador = contador + %{S}(%{A});", R:"return contador;"
          },
          f:{
            E:"%{I}contador = 0;\nfor(%{F}){\n  %{P}\n%{N}%{B}%{R}",
            P:"contador = contador + %{S}(%{A});", R:"return contador;"
          },
          r:{
            E:"return %{E} ? %{REC}(%{T}) + %{S}(%{H}) : 0;"
          },
          h:{
            E:"TODO"
          }
        },
        AC:{
          w:{
            E:"%{I}contador = 0;\nwhile(%{E}){\n  %{P}\n%{N}%{B}%{R}",
            P:"contador = contador + unoSi_OCeroSiNo(%{S}(%{A}));", R:"return contador;",
            bib:["unoSi_OCeroSiNo"]
          },
          f:{
            E:"%{I}contador = 0;\nfor(%{E}){\n  %{P}\n%{N}%{B}%{R}",
            P:"contador = contador + unoSi_OCeroSiNo(%{S}(%{A}));", R:"return contador;",
            bib:["unoSi_OCeroSiNo"]
          },
          r:{
            E:"return %{E} ? %{REC}(%{T}) + unoSi_OCeroSiNo(%{S}(%{H})) : 0;",
            bib:["unoSi_OCeroSiNo"]
          },
          h:{
            E:"TODO"
          }
        },
        B:{
          w:{
            E:"%{I}while(%{E} && !%{S}(%{A})){\n%{N}%{R}",
            R:"return %{R};"
          },
          r:{
            E:"return %{E} && (%{S}(%{H}) || %{REC}(%{T}));"
          },
          h:{
            E:"TODO"
          }
        },
        BS:{
          w:{E:"%{I}while(!%{S}(%{A})){\n%{N}%{R}",
            R:"return %{A};"
          },
          r:{
            EP:"if (!%{S}(%{H})) {\n%{N}%{REC}(%{T});\n}",
            EF:"return %{S}(%{H}) ? %{H} : %{REC}(%{T});"
          },
          h:{
            E:"TODO"
          }
        },
        M:{
          w:{
            E:"%{I}mejorPorAhora = %{A};\nwhile(%{E}){\n  %{P}\n%{N}%{B}%{R}",
            P:"mejorPorAhora = %{S}(mejorPorAhora, %{A});", R:"return mejorPorAhora;"
          },
          f:{
            E:"%{I}mejorPorAhora = %{H};\nfor(%{T}){\n  %{P}\n%{N}%{B}%{R}",
            P:"mejorPorAhora = %{S}(mejorPorAhora, %{A});", R:"return mejorPorAhora;"
          },
          r:{
            E:"return %{Em} ? %{S}(%{REC}(%{T}), %{H}) : %{H};"
          },
          h:{
            E:"TODO"
          }
        },
        T:{
          w:{
            E:"%{I}listaTransformadaPorAhora = [];\nwhile(%{E}){\n  %{P}\n%{N}%{B}%{R}",
            P:"listaTransformadaPorAhora.push(%{S}(%{A}));",
            R:"return listaTransformadaPorAhora;"
          },
          f:{
            E:"%{I}listaTransformadaPorAhora = [];\nfor(%{F}){\n  %{P}\n%{N}%{B}%{R}",
            P:"listaTransformadaPorAhora.push(%{S}(%{A}));",
            R:"return listaTransformadaPorAhora;"
          },
          r:{
            E:"return %{E} ? %{S}(%{H}) + %{REC}(%{T}) : [];"
          },
          h:{
            E:"TODO"
          }
        },
        F:{
          w:{
            E:"%{I}listaFiltradaPorAhora = [];\nwhile(%{E}){\n  %{P}\n%{N}%{B}%{R}",
            P:"if (%{S}(%{A})) {\n  listaFiltradaPorAhora.push(%{A});\n}",
            R:"return listaFiltradaPorAhora;"
          },
          f:{
            E:"%{I}listaFiltradaPorAhora = [];\nfor(%{F}){\n  %{P}\n%{N}%{B}%{R}",
            P:"if (%{S}(%{A})) {\n  listaFiltradaPorAhora.push(%{A});\n}",
            R:"return listaFiltradaPorAhora;"
          },
          r:{
            E:"return %{E} ? singular_Si_(%{H}, %{S}(%{H})) + %{REC}(%{T}) : [];",
            bib:["singular_Si_"]
          },
          h:{
            E:"TODO"
          }
        }
      },
      H:{
        A:{
          r:{E:"%{REC} %{CB} = 0\n%{REC} %{CR} = %{S} %{H} + %{REC} %{T}", noname: true},
          h:{E:"foldr ((+) . %{S}) 0"}
        },
        AC:{
          r:{
            E:"%{REC} %{CB} = 0\n%{REC} %{CR} = unoSi_OCeroSiNo(%{S} %{H}) + %{REC} %{T}",
            bib:["unoSi_OCeroSiNo"], noname: true
          },
          h:{E:"foldr ((+) . (unoSi_OCeroSiNo . %{S})) 0",bib:["unoSi_OCeroSiNo"]}
        },
        B:{
          r:{E:"%{REC} %{CB} = False\n%{REC} %{CR} = %{S} %{H} or %{REC} %{T}", noname: true},
          h:{E:"any %{S}"}
        },
        BS:{
          r:{E:"%{REC} %{CR} = if %{S} %{H} then %{H} else %{REC} %{T}", noname: true},
          h:{E:"fromJust . find %{S}", imp:["List","Maybe"]}
        },
        M:{
          r:{E:"%{REC} %{CR} = if %{E} %{T} then %{H} else %{S}(%{H}, %{REC} %{T})", noname: true},
          h:{E:"foldr1 %{S}"}
        },
        T:{
          r:{E:"%{REC} %{CB} = []\n%{REC} %{CR} = %{S} %{H} : %{REC} %{T}", noname: true},
          h:{E:"map %{S}"}
        },
        F:{
          r:{E:"%{REC} %{CB} = []\n%{REC} %{CR} = if %{S} %{H} then %{H} : %{REC} %{T} else %{REC} %{T}", noname: true},
          h:{E:"filter %{S}"}
        }
      }
    };
    const codigosColeccion = {
      G:{
        T:{
          w:{
            I:"IrAPrimeraCeldaEnRecorridoAl_YAl_(Este, Norte)",
            E:"haySiguienteCeldaEnRecorridoAl_YAl_(Este, Norte)",
            N:"PasarASiguienteCeldaEnRecorridoAl_YAl_(Este, Norte)",
            R:"%{S}(%{A})",
            B:true
          }
        },
        C:{
          w:{
            A:"colorActual",
            I:"colorActual := minColor()",
            E:"colorActual /= maxColor()",
            N:"colorActual := siguiente(colorActual)",
            R:"%{S}(%{A})",
            B:true
          }
        },
        D:{
          w:{
            A:"direcciónActual",
            I:"direcciónActual := minDir()",
            E:"direcciónActual /= maxDir()",
            N:"direcciónActual := siguiente(direcciónActual)",
            R:"%{S}(%{A})",
            B:true
          }
        },
        L:{
          w:{
            A:"primero(listaRestante)",
            I:"listaRestante := listaCompleta",
            E:"not esVacía(listaRestante)",
            N:"listaRestante := resto(listaRestante)",
            R:"not esVacía(listaRestante)",
            B:false
          },
          f:{
            A:"elementoActual",
            F:"elementoActual in listaCompleta",
            H:"primero(listaCompleta)",
            T:"elementoActual in resto(listaCompleta)",
            B:false
          }
        },
        N:{
          w:{
            A:"i",
            I:"i := 0",
            N:"i := i+1",
          }
        }
      },
      P:{
        C:{
          w:{
            A:"colorActual",
            I:"colorActual = minColor()",
            E:"colorActual != maxColor()",
            N:"colorActual = colorSiguiente(colorActual)",
            R:"%{S}(%{A})",
            B:true,
            imp:["Enum","Color"],
            bib:["minColor","maxColor","colorSiguiente"]
          },
          f:{
            A:"colorActual",
            F:"colorActual in Color",
            H:"minColor()",
            T:"colorActual in Color",
            B:false,
            imp:["Color"],
            bib:["minColor"]
          }
        },
        D:{
          w:{
            A:"direcciónActual",
            I:"direcciónActual = minDir()",
            E:"direcciónActual != maxDir()",
            N:"direcciónActual = dirSiguiente(direcciónActual)",
            R:"%{S}(%{A})",
            B:true,
            imp:["Enum","Dir"],
            bib:["minDir","maxDir","dirSiguiente"]
          },
          f:{
            A:"direcciónActual",
            F:"direcciónActual in Dirección",
            H:"minDir()",
            T:"direcciónActual in Dirección",
            B:false,
            imp:["Dir"],
            bib:["minDir"]
          }
        },
        L:{
          w:{
            A:"listaRestante[0]",
            I:"listaRestante = listaCompleta",
            E:"len(listaRestante) > 0",
            N:"listaRestante = listaRestante[1:]",
            R:"len(listaRestante) > 0",
            B:false
          },
          f:{
            A:"elementoActual",
            F:"elementoActual in listaCompleta",
            H:"listaCompleta[0]",
            T:"elementoActual in listaCompleta[1:]",
            B:false
          },
          r:{
            E:"len(lista) > 0",
            Em:"len(lista) > 1",
            H:"lista[0]",
            T:"lista[1:]",
            B:false
          },
          h:{
            // TODO
          }
        },
        N:{
          w:{
            A:"i",
            I:"i = 0",
            N:"i = i+1",
          }
        }
      },
      J:{
        C:{
          w:{
            A:"colorActual",
            I:"let colorActual = minColor();",
            E:"colorActual != maxColor()",
            N:"colorActual = siguiente(colorActual);",
            R:"%{S}(%{A})",
            B:true,
            imp:["Color"],
            bib:["minColor","maxColor","colorSiguiente"]
          },
          f:{
            A:"colorActual",
            F:"colorActual of Object.values(Color)",
            H:"minColor",
            T:"colorActual of Object.values(Color).slice(1)",
            B:false,
            imp:["Color"],
            bib:["minColor"]
          }
        },
        D:{
          w:{
            A:"direcciónActual",
            I:"let direcciónActual = minDir();",
            E:"direcciónActual != maxDir()",
            N:"direcciónActual = dirSiguiente(direcciónActual);",
            R:"%{S}(%{A})",
            B:true,
            imp:["Dir"],
            bib:["minDir","maxDir","dirSiguiente"]
          },
          f:{
            A:"direcciónActual",
            F:"direcciónActual of Object.values(Dirección)",
            H:"minDir",
            T:"direcciónActual of Object.values(Dirección).slice(1)",
            B:false,
            imp:["Dir"],
            bib:["minDir"]
          }
        },
        L:{
          w:{
            A:"listaRestante[0]",
            I:"let listaRestante = listaCompleta;",
            E:"listaRestante.length > 0",
            N:"listaRestante = listaRestante.slice(1);",
            R:"listaRestante.length > 0",
            B:false
          },
          f:{
            A:"elementoActual",
            F:"elementoActual of listaCompleta",
            H:"listaCompleta[0]",
            T:"elementoActual of listaCompleta.slice(1)",
            B:false
          },
          r:{
            E:"lista.length > 0",
            Em:"lista.length > 1",
            H:"lista[0]",
            T:"lista.slice(1)",
            B:false
          },
          h:{
            // TODO
          }
        },
        N:{
          w:{
            A:"i",
            I:"let i = 0;",
            N:"i = i+1;",
          }
        }
      },
      H:{
        L:{
          r:{
            E: "null",
            CB:"[]",
            CR:"(x:xs)",
            H:"x",
            T:"xs"
          },
          h:{}
        }
      }
    };
    const codigosOtros = {
      G:{
        AD:"() {\n  ", CD:"\n}", AC:"/*", CC:"*/",
        P:"procedure ", F:"function ",
        mecanismos: ["w","f"]
      },
      P:{
        AD:"():\n  ", AC:"'''", CC:"'''",
        P:"def ", F:"def ",
        mecanismos: ["w","f","r","h"]
      },
      J:{
        AD:"() {\n  ", CD:"\n}", AC:"/*", CC:"*/",
        P:"function ", F:"function ",
        mecanismos: ["w","f","r","h"]
      },
      H:{
        AD:" = ", CD:"", AC:"{--", CC:"--}",
        F:"",
        mecanismos: ["r","h"]
      }
    };

    const selectorLenguaje = document.getElementById("selectorLenguaje");
    const selectorClase = document.getElementById("selectorClase");
    const selectorNombre = document.getElementById("selectorNombre");
    const selectorTipo = document.getElementById("selectorTipo");
    const selectorColeccion = document.getElementById("selectorColeccion");
    const selectorSubtarea = document.getElementById("selectorSubtarea");
    const selectorMecanismo = document.getElementById("selectorMecanismo");
    const output = document.getElementById("output");
    const abrirDefinicion = document.getElementById("abrirDefinición");
    const cerrarDefinicion = document.getElementById("cerrarDefinición");
    const abrirComentario = document.getElementById("abrirComentario");
    const cerrarComentario = document.getElementById("cerrarComentario");
    const opciones = [
      {name:"lenguaje", selector: selectorLenguaje, opciones:[
        {k:"G", n:"Gobstones"},
        {k:"P", n:"Python"},
        {k:"J", n:"Javascript"},
        {k:"H", n:"Haskell"}
      ], title:"el lenguaje", error: function(src, actual) {
        return `El lenguaje ${actual} no soporta ${src.opt} ${src.name}`
      }, validaciones:{
        clase: (v) => ((x) => x in codigosOtros[v]),
        tipo: (v) => ((x) => x in codigosTipo[v]),
        coleccion: (v) => ((x) => x in codigosColeccion[v]),
        mecanismo: (v) => ((x) => codigosOtros[v].mecanismos.includes(x))
      }},
      {name:"mecanismo", selector: selectorMecanismo, opciones:[
        {k:"w", n:"Repetición condicional"},
        {k:"f", n:"Repetición indexada"},
        {k:"r", n:"Recursión"},
        {k:"h", n:"Alto orden"}
      ], title: "el mecanismo de", error: function(src, actual) {
        return `El mecanismo de ${actual} no está disponible para ${src.opt} ${src.name}`
      }, validaciones:{
        lenguaje: (v) => ((x) => codigosOtros[x].mecanismos.includes(v)),
        coleccion: (v) => ((x) => mecanismosPorColeccion[x].includes(v)),
        tipo: (v) => ((x) => v != "f" || (v == "f" && !["B","BS"].includes(x)))
      }},
      {name:"clase", selector: selectorClase, opciones:[
        {k:"P", n:"procedimiento"},
        {k:"F", n:"función"}
      ], title:"un", error: function(src, actual) {
        return `Un ${actual} no se puede definir con ${src.opt} ${src.name}`
      }, validaciones:{
        lenguaje: (v) => ((x) => v in codigosOtros[x]),
        tipo: (v) => ((x) => (v == "P" && ["P","BS"].includes(x)) || (v == "F" && x != "P"))
      }},
      {name:"tipo", selector: selectorTipo, opciones:[
        {k:"P", n:"procesamiento"},
        {k:"A", n:"acumulación"},
        {k:"AC", n:"acumulación condicional"},
        {k:"B", n:"búsqueda indagatoria"},
        {k:"BS", n:"búsqueda segura"},
        {k:"M", n:"mínimo/máximo"},
        {k:"T", n:"transformación"},
        {k:"F", n:"filtro"}
      ], title:"el esquema de recorrido de", error: function(src, actual) {
        return `El esquema de recorrido de ${actual} no se puede realizar con ${src.opt} ${src.name}`
      }, validaciones:{
        lenguaje: (v) => ((x) => v in codigosTipo[x]),
        coleccion: (v) => ((x) => tiposPorColeccion[x].includes(v)),
        clase: (v) => ((x) => (x == "P" && ["P","BS"].includes(v)) || (x == "F" && v != "P")),
        mecanismo: (v) => ((x) => x != "f" || (x == "f" && !["B","BS"].includes(v)))
      }},
      {name:"coleccion", selector: selectorColeccion, opciones:[
        {k:"T", n:"el tablero",
          tipos:["P","A","AC","B","BS","M"], mecanismos:["w"]
        },
        {k:"C", n:"los colores",
          tipos:["P","A","AC","B","BS","M"], mecanismos:["w"]
        },
        {k:"D", n:"las direcciones",
          tipos:["P","A","AC","B","BS","M"], mecanismos:["w"]
        },
        {k:"L", n:"una lista",
          tipos:["P","A","AC","B","BS","M","T","F"], mecanismos:["w","f","r","h"]
        },
        {k:"N", n:"los números naturales",
          tipos:["BS"], mecanismos:["w"]
        }
      ], title:"la colección", error: function(src, actual) {
        return `La colección ${actual} no se puede recorrer con ${src.opt} ${src.name}`
      }, validaciones:{
        lenguaje: (v) => ((x) => v in codigosColeccion[x]),
        tipo: (v) => ((x) => tiposPorColeccion[v].includes(x)),
        mecanismo: (v) => ((x) => mecanismosPorColeccion[v].includes(x))
      }}
    ];
    const datosDeOpcion = function(objeto, clave, nombre) {
      for (let o of objeto) {
        if (o[clave] == nombre) {
          return o;
        }
      }
    };
    const validarSelector = function(nombre, f, src) {
      let res = "";
      const datos = datosDeOpcion(opciones, "name", nombre);
      const selector = datos.selector;
      let actual = selector.value;
      if (actual === '') {
        actual = datos.opciones.filter(x => f(x.k))[0].k;
      } else if (!f(actual)) {
        res = datos.error(src, datosDeOpcion(datos.opciones, "k", actual).n);
        if (!tmpErrores.some(x => x.src == src.k && x.v == nombre)) {
          tmpErrores.push({src:src.k, v:nombre});
        }
      }
      return res;
    };
    let tmpErrores = [];
    const actualizarOpciones = function(e) {
      let opcionElegida = e.target.getAttribute('name');
      const res = [];
      for (let e of tmpErrores) {
        if (e.src == opcionElegida) {
          e.d = true;
        } else {
          let datosTmp = datosDeOpcion(opciones, "name", e.src);
          let nuevoValor = datosTmp.selector.value;
          let v = validarSelector(e.v, datosTmp.validaciones[e.v](nuevoValor), {
            k:e.src, opt:datosTmp.title, name:datosDeOpcion(datosTmp.opciones, "k", nuevoValor).n
          });
          if (v.length == 0) {
            e.d = true;
          } else {
            res.push(v);
          }
        }
      }
      const datos = datosDeOpcion(opciones, "name", opcionElegida);
      if (datos) {
        let valorElegido = e.target.value;
        const src = {
          k:opcionElegida,
          opt:datos.title,
          name:datosDeOpcion(datos.opciones, "k", valorElegido).n
        };
        tmpErrores = tmpErrores.filter(x => !('d' in x));
        for (let v in datos.validaciones) {
          res.push(validarSelector(v, datos.validaciones[v](valorElegido), src));
        }
      }
      return res.filter(x => x.length > 0).join("\n\n* ");
    };
    const actualizarOutput = function(e) {
      if (e) {
        let res = actualizarOpciones(e);
        if (res != "") {
          output.value = "Combinación inválida:\n\n* " + res;
          return;
        }
      }
      const lenguaje = selectorLenguaje.value;
      const clase = selectorClase.value;
      const nombre = selectorNombre.value;
      let claveTipo = selectorTipo.value;
      let claveColeccion = selectorColeccion.value;
      const subtarea = selectorSubtarea.value;
      const mecanismo = selectorMecanismo.value;
      const otros = codigosOtros[lenguaje];
      let bibliotecas = [];
      let modulos = [];
      const tipo = codigosTipo[lenguaje][claveTipo][mecanismo];
      const coleccion = codigosColeccion[lenguaje][claveColeccion][mecanismo];
      if ('bib' in tipo) {
        bibliotecas = bibliotecas.concat(tipo.bib).map(x => codigosBiblioteca[lenguaje][x]);
      }
      if ('bib' in coleccion) {
        bibliotecas = bibliotecas.concat(coleccion.bib).map(x => codigosBiblioteca[lenguaje][x]);
      }
      if (bibliotecas.length > 0) {
        bibliotecas = "\n\n" + bibliotecas.join("\n\n");
      } else {
        bibliotecas = "";
      }
      if ('imp' in tipo) {
        modulos = modulos.concat(tipo.imp).map(x => codigosImport[lenguaje][x]);
      }
      if ('imp' in coleccion) {
        modulos = modulos.concat(coleccion.imp).map(x => codigosImport[lenguaje][x]);
      }
      if (modulos.length > 0) {
        modulos = modulos.join("\n") + "\n\n";
      } else {
        modulos = "";
      }
      let esquema = (
        `E${clase}` in tipo
        ? tipo[`E${clase}`]
        : tipo.E
      );
      let encabezado = ('noname' in tipo ? '' : otros[clase] + nombre + otros.AD);
      output.value = modulos + encabezado + esquema
        .replace("%{I}", coleccion.I ? coleccion.I + '\n' : '')
        .replace("%{E}", (coleccion.E || 'true'))
        .replace("%{Em}", (coleccion.Em || 'true'))
        .replace("%{N}",
          (coleccion.N ? "  " + coleccion.N : '') +
          ((coleccion.N && otros.CD) ? '\n' : '') + 
          (otros.CD || ''))
        .replace("%{R}", (tipo.R && clase == 'F') ?
          ('\n' + tipo.R.replace("%{R}", (coleccion.R || ''))) : ''
        )
        .replace("%{B}", (coleccion.B && tipo.P) ? '\n' + tipo.P : '')
        .replace("%{P}", tipo.P ? tipo.P.replaceAll('\n', "\n  ") : '')
        .replaceAll("%{S}", subtarea)
        .replaceAll("%{F}", coleccion.F || '')
        .replaceAll("%{A}", (coleccion.A || ''))
        .replaceAll("%{H}", coleccion.H || '')
        .replaceAll("%{T}", coleccion.T || '')
        .replaceAll("%{CB}", coleccion.CB || '')
        .replaceAll("%{CR}", coleccion.CR || '')
        .replaceAll("%{REC}", nombre || '')
        .replaceAll('\n', ('noname' in tipo ? '\n' : "\n  "))
      + (otros.CD || '') + bibliotecas;
      abrirDefinicion.innerHTML = otros.AD;
      cerrarDefinicion.innerHTML = (otros.CD || '');
      abrirComentario.innerHTML = otros.AC;
      cerrarComentario.innerHTML = otros.CC;
    };
    const tiposPorColeccion = {};
    for (let c of datosDeOpcion(opciones, "name", "coleccion").opciones) {
      tiposPorColeccion[c.k] = c.tipos;
    }
    const mecanismosPorColeccion = {};
    for (let c of datosDeOpcion(opciones, "name", "coleccion").opciones) {
      mecanismosPorColeccion[c.k] = c.mecanismos;
    }
    selectorLenguaje.onchange = actualizarOutput;
    selectorClase.onchange = actualizarOutput;
    selectorNombre.onchange = actualizarOutput;
    selectorTipo.onchange = actualizarOutput;
    selectorColeccion.onchange = actualizarOutput;
    selectorSubtarea.onchange = actualizarOutput;
    selectorMecanismo.onchange = actualizarOutput;
    const argumentoURL = function(clave) {
      let url = location.href;
      clave = clave.replace(/[\[]/,"\\[").replace(/[\]]/,"\\]");
      let regexS = "[\\?&]"+clave+"=([^&#]*)";
      let regex = new RegExp( regexS );
      let results = regex.exec( url );
      return results == null ? null : results[1];
    };
    window.onerror = function(msg, url, line, col, error) {
      alert(" -- ERROR --\n\n" + msg);
    }
    window.onload = function() {
      const inicializacion = {
        "lenguaje":"G",
        "mecanismo":"w",
        "clase":"P",
        "tipo":"P",
        "coleccion":"T"
      };
      for (let s in inicializacion) {
        let v = argumentoURL(s);
        if (v != null) {
          inicializacion[s] = v;
        }
      }
      for (let s in inicializacion) {
        let datos = datosDeOpcion(opciones, "name", s)
        let contenido = "";
        for (let o of datos.opciones) {
          contenido += `<option value="${o.k}"${o.k == inicializacion[s] ? ' selected' : ''}>${o.n}</option>`;
        }
        datos.selector.innerHTML = contenido;
      }
      for (let s in inicializacion) {
        actualizarOpciones({target:{getAttribute:x=>s, value:inicializacion[s]}});
      }
      actualizarOutput();
    };
    const test = function(data) {
      for (let o of opciones) {
        o.selector.value = data[o.name];
        actualizarOutput({target:{getAttribute:x=>o.name, value:data[o.name]}});
      }
    };
    const testAll = function() {
      const f = function(ops) {
        if (ops.length == 0) {
          return [{}];
        } else {
          return f(ops.slice(1)).map((r) => ops[0].opciones.map((o) => Object.assign({[ops[0].name]:o.k}, r))).flat();
        }
      };
      const todo = f(opciones.toReversed());
      const unit = function(ops) {
        if (ops.length == 0) {
          alert("FIN");
        } else {
          console.log(ops.length);
          test(ops[0]);
          setTimeout(function() { unit(ops.slice(1)); }, 1);
        }
      };
      unit(todo);
    };
  </script>
</html>
